#pragma once
#include<iostream>
#include"Iterator.h"
using namespace std;

template<class T>
struct node
{
	string data;
	node<T>* next=nullptr;
	node<T>* prev=nullptr;
};

template<class type>
class Linked_List
{
private:
	node<T>* head;
	node<T>* tail;
	int size;
public:
	Linked_List()
	{
		head = nullptr;
		tail = nullptr;
		size = 0;
	}

	Iterator begin() //this function will store head in itereator ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	{
		Iterator I(head);////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		return I;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	Iterator end() //this function will store tail in itereator//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	{
		Iterator It(tail);///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		return It;///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}

	void copyconstructor()
	{

	}

	node* gethead()
	{
		return this->head;
	}

	node* gettail()
	{
		return this->tail;
	}

	void addToFront(string value)
	{
		node* tmp = new node;
		tmp->data = value;

		if (this->head == nullptr)
			this->head = this->tail = tmp;
		else
		{
			this->tail->next = tmp;
			tmp->prev = this->tail;
			this->tail = this->tail->next;
		}
	}

	void addToRear(string value)
	{
		node* tmp = new node;
		tmp->data = value;

		if (head == nullptr)
			this->head = this->tail = tmp;
		else
		{
			tmp->next = this->head;
			this->head->prev = tmp;
			this->head = this->head->prev;
		}
	}

	void print()
	{
		node* itr = this->head;
		while (itr != nullptr)
		{
			cout << itr->data << endl;
			itr = itr->next;
		}
		cout << endl;
	}

	void deleteFront()
	{
		if (head != nullptr)
		{
			node* tmp = this->head;
			this->head = this->head->next;
			this->head->prev = nullptr;
			delete tmp;
		}
	}

	~Linked_List()
	{
		while (head != nullptr)
			deleteFront();
	}
};

